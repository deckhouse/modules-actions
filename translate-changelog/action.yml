name: 'Translate Changelog and Create PR'
description: 'Translates changelog files between languages and creates a PR'

inputs:
  changelog_path:
    description: 'Path to CHANGELOG directory'
    required: false
    default: 'CHANGELOG'
  file_prefix:
    description: 'Prefix for changelog files (e.g., "CHANGELOG-v" or "v")'
    required: false
    default: 'v'
  source_lang:
    description: 'Source language code (ru or en)'
    required: false
    default: 'ru'
  target_lang:
    description: 'Target language code (en or ru)'
    required: false
    default: 'en'
  github_token:
    description: 'GitHub token for creating pull requests'
    required: false
  python_version:
    description: 'Python version to use'
    required: false
    default: '3.11'
  base_branch:
    description: 'Base branch for the pull request'
    required: false
    default: 'main'

outputs:
  version:
    description: 'Version of the translated changelog'
  source_file:
    description: 'Source changelog file name'
  target_file:
    description: 'Target changelog file name'
  has_changes:
    description: 'Whether CHANGELOG files were changed in the last commit'

runs:
  using: "composite"
  steps:
    - name: Check if CHANGELOG files changed in last commit
      id: check_changes
      shell: bash
      run: |
        # Проверить, есть ли изменения в CHANGELOG файлах в последнем коммите
        CHANGELOG_PATH="${{ inputs.changelog_path }}"
        FILE_PREFIX="${{ inputs.file_prefix }}"
        SOURCE_LANG="${{ inputs.source_lang }}"

        # Определить паттерн исходных файлов на основе source_lang
        if [ "$SOURCE_LANG" = "en" ]; then
          # Для английского ищем файлы без языкового суффикса
          FILE_PATTERN="^${CHANGELOG_PATH}/${FILE_PREFIX}[0-9]+\.[0-9]+\.[0-9]+\.yml$"
        else
          # Для других языков ищем файлы с языковым суффиксом
          FILE_PATTERN="^${CHANGELOG_PATH}/${FILE_PREFIX}[0-9]+\.[0-9]+\.[0-9]+\.${SOURCE_LANG}\.yml$"
        fi

        # Получить список измененных файлов в последнем коммите
        CHANGED_FILES=$(git show --name-only --pretty=format: HEAD | grep -E "$FILE_PATTERN" || true)

        if [ -n "$CHANGED_FILES" ]; then
          echo "CHANGELOG files changed in last commit (source_lang=$SOURCE_LANG):"
          echo "$CHANGED_FILES"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          echo "No CHANGELOG files changed in last commit for source_lang=$SOURCE_LANG, skipping"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Set up Python
      if: steps.check_changes.outputs.has_changes == 'true'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ inputs.python_version }}

    - name: Install dependencies
      if: steps.check_changes.outputs.has_changes == 'true'
      shell: bash
      run: |
        pip install pyyaml deep-translator packaging

    - name: Find latest changelog
      if: steps.check_changes.outputs.has_changes == 'true'
      id: find_changelog
      shell: bash
      run: |
        cd "${{ inputs.changelog_path }}"

        export FILE_PREFIX="${{ inputs.file_prefix }}"
        export SOURCE_LANG="${{ inputs.source_lang }}"
        export TARGET_LANG="${{ inputs.target_lang }}"

        # Найти все файлы исходного языка и отсортировать по semver
        python3 << 'EOF'
        import os
        import re
        from packaging import version

        file_prefix = os.environ.get('FILE_PREFIX', 'CHANGELOG-v')
        source_lang = os.environ.get('SOURCE_LANG', 'ru')
        target_lang = os.environ.get('TARGET_LANG', 'en')

        # Определить паттерн файлов на основе source_lang
        if source_lang == 'en':
            # Для английского ищем файлы без языкового суффикса
            file_pattern = re.compile(rf'^{re.escape(file_prefix)}(\d+\.\d+\.\d+)\.yml$')
            source_suffix = ''
        else:
            # Для других языков ищем файлы с языковым суффиксом
            file_pattern = re.compile(rf'^{re.escape(file_prefix)}(\d+\.\d+\.\d+)\.{re.escape(source_lang)}\.yml$')
            source_suffix = f'.{source_lang}'

        files = [f for f in os.listdir('.') if file_pattern.match(f)]

        # Извлечь версии из имен файлов
        versions = []
        for f in files:
            match = file_pattern.match(f)
            if match:
                versions.append((version.parse(match.group(1)), f))

        if not versions:
            print(f"No changelog files found for source language: {source_lang}")
            exit(1)

        # Отсортировать по версии (последняя версия первая)
        versions.sort(reverse=True)
        latest_version, source_file = versions[0]

        # Определить имя целевого файла
        version_str = f"{latest_version}"
        if target_lang == 'en':
            # Для английского целевой файл без языкового суффикса
            target_file = f"{file_prefix}{version_str}.yml"
        else:
            # Для других языков целевой файл с языковым суффиксом
            target_file = f"{file_prefix}{version_str}.{target_lang}.yml"
        
        github_output = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
        with open(github_output, 'a') as f:
            f.write(f"version=v{version_str}\n")
            f.write(f"source_file={source_file}\n")
            f.write(f"target_file={target_file}\n")
        print(f"Latest version: v{version_str}, source: {source_file}, target: {target_file}")
        EOF
      continue-on-error: true

    - name: Translate changelog
      if: steps.check_changes.outputs.has_changes == 'true' && steps.find_changelog.outcome == 'success'
      id: translate
      shell: bash
      env:
        SOURCE_FILE: ${{ steps.find_changelog.outputs.source_file }}
        TARGET_FILE: ${{ steps.find_changelog.outputs.target_file }}
        SOURCE_LANG: ${{ inputs.source_lang }}
        TARGET_LANG: ${{ inputs.target_lang }}
      run: |
        cd "${{ inputs.changelog_path }}"

        python3 << 'EOF'
        from deep_translator import GoogleTranslator
        import os
        import yaml

        source_file = os.environ['SOURCE_FILE']
        target_file = os.environ['TARGET_FILE']
        source_lang = os.environ['SOURCE_LANG']
        target_lang = os.environ['TARGET_LANG']

        # Загрузить YAML файл
        with open(source_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)

        # Инициализировать переводчик
        translator = GoogleTranslator(source=source_lang, target=target_lang)

        def translate_value(value):
            """Рекурсивно переводит значения в структуре данных"""
            if isinstance(value, str):
                # Переводим строку
                try:
                    return translator.translate(value)
                except Exception as e:
                    print(f"Warning: Failed to translate '{value[:50]}...': {e}")
                    return value
            elif isinstance(value, dict):
                # Рекурсивно обрабатываем словарь (ключи остаются без изменений)
                return {key: translate_value(val) for key, val in value.items()}
            elif isinstance(value, list):
                # Рекурсивно обрабатываем список
                return [translate_value(item) for item in value]
            else:
                # Другие типы (числа, bool, None) возвращаем без изменений
                return value

        # Перевести все значения в структуре
        translated_data = translate_value(data)

        # Сохранить переведенный YAML
        with open(target_file, 'w', encoding='utf-8') as f:
            yaml.dump(translated_data, f, allow_unicode=True, default_flow_style=False, sort_keys=False)

        print(f"Translated {source_file} ({source_lang}) to {target_file} ({target_lang})")
        EOF

    - name: Get current branch name and create translation branch
      if: steps.check_changes.outputs.has_changes == 'true' && steps.find_changelog.outcome == 'success'
      id: get_branch
      shell: bash
      run: |
        VERSION="${{ steps.find_changelog.outputs.version }}"
        SOURCE_LANG="${{ inputs.source_lang }}"
        TARGET_LANG="${{ inputs.target_lang }}"
        
        # Создать имя новой ветки для перевода
        TRANSLATION_BRANCH="translation/${SOURCE_LANG}-to-${TARGET_LANG}/${VERSION}"
        
        # Проверить существует ли ветка локально или на remote
        if git show-ref --verify --quiet "refs/heads/$TRANSLATION_BRANCH"; then
          # Ветка существует локально, переключаемся на нее
          git checkout "$TRANSLATION_BRANCH"
          echo "Switched to existing local branch: $TRANSLATION_BRANCH"
        elif git ls-remote --heads origin "$TRANSLATION_BRANCH" | grep -q "$TRANSLATION_BRANCH"; then
          # Ветка существует на remote, получаем ее
          git fetch origin "$TRANSLATION_BRANCH"
          git checkout -b "$TRANSLATION_BRANCH" "origin/$TRANSLATION_BRANCH"
          echo "Checked out existing remote branch: $TRANSLATION_BRANCH"
        else
          # Ветка не существует, создаем новую
          git checkout -b "$TRANSLATION_BRANCH"
          echo "Created new branch: $TRANSLATION_BRANCH"
        fi
        
        echo "branch=$TRANSLATION_BRANCH" >> $GITHUB_OUTPUT

    - name: Commit translated changelog
      if: steps.check_changes.outputs.has_changes == 'true' && steps.find_changelog.outcome == 'success'
      shell: bash
      run: |
        VERSION="${{ steps.find_changelog.outputs.version }}"
        SOURCE_LANG="${{ inputs.source_lang }}"
        TARGET_LANG="${{ inputs.target_lang }}"

        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add "${{ inputs.changelog_path }}/"
        git commit -m "Translate changelog ${VERSION} from ${SOURCE_LANG} to ${TARGET_LANG}"
        
        # Пушим коммит в текущую ветку (force push, так как обновляем перевод)
        git push -f origin HEAD

    - name: Create Pull Request using GitHub CLI
      if: steps.check_changes.outputs.has_changes == 'true' && steps.find_changelog.outcome == 'success'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        BRANCH_NAME="${{ steps.get_branch.outputs.branch }}"
        BASE_BRANCH="${{ inputs.base_branch }}"
        VERSION="${{ steps.find_changelog.outputs.version }}"
        SOURCE_LANG="${{ inputs.source_lang }}"
        TARGET_LANG="${{ inputs.target_lang }}"
        SOURCE_FILE="${{ steps.find_changelog.outputs.source_file }}"
        TARGET_FILE="${{ steps.find_changelog.outputs.target_file }}"
        CHANGELOG_PATH="${{ inputs.changelog_path }}"

        # Проверить, существует ли уже PR для этой ветки
        EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --base "$BASE_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

        if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
          echo "PR #$EXISTING_PR already exists for branch $BRANCH_NAME"
          exit 0
        fi

        # Определить полные названия языков для PR
        case "$SOURCE_LANG" in
          ru) SOURCE_LANG_NAME="Russian" ;;
          en) SOURCE_LANG_NAME="English" ;;
          *) SOURCE_LANG_NAME="$SOURCE_LANG" ;;
        esac

        case "$TARGET_LANG" in
          ru) TARGET_LANG_NAME="Russian" ;;
          en) TARGET_LANG_NAME="English" ;;
          *) TARGET_LANG_NAME="$TARGET_LANG" ;;
        esac

        # Создать PR body файл
        PR_BODY_FILE=$(mktemp)
        
        echo "## Changelog $VERSION" > "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "This PR contains the $TARGET_LANG_NAME translation of the $SOURCE_LANG_NAME changelog for version $VERSION." >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "**Source file:** \`$CHANGELOG_PATH/$SOURCE_FILE\`" >> "$PR_BODY_FILE"
        echo "**Translated file:** \`$CHANGELOG_PATH/$TARGET_FILE\`" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "<details>" >> "$PR_BODY_FILE"
        echo "<summary>Changelog content</summary>" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "\`\`\`yaml" >> "$PR_BODY_FILE"
        cat "$CHANGELOG_PATH/$TARGET_FILE" >> "$PR_BODY_FILE"
        echo "\`\`\`" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        echo "</details>" >> "$PR_BODY_FILE"
        
        # Создать PR
        gh pr create \
          --base "$BASE_BRANCH" \
          --head "$BRANCH_NAME" \
          --title "$VERSION" \
          --body-file "$PR_BODY_FILE"
        
        # Удалить временный файл
        rm -f "$PR_BODY_FILE"
