name: "Gitleaks scan"
description: "Run Gitleaks in full or diff mode (composite action, configurable version)"

inputs:
  scan_mode:
    description: "Scan mode: full | diff"
    required: false
    default: "full"
  gitleaks_version:
    description: "Gitleaks version to install"
    required: false
    default: "v8.28.0"
  checkout_repo:
    description: "owner/repo to checkout (PR head)"
    required: false
    default: "${{ github.repository }}"
  checkout_ref:
    description: "ref/sha to checkout (PR head SHA)"
    required: false
    default: ""
  base_sha:
    description: "Base SHA for diff (PR base SHA)"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Checkout (PR head or default)
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.checkout_repo }}
        ref: ${{ inputs.checkout_ref }}
        fetch-depth: 0
        persist-credentials: false

    - name: Install Gitleaks
      shell: bash
      run: |
        set -euo pipefail
        ver="${{ inputs.gitleaks_version }}"
        file_ver="${ver#v}"

        arch="$(uname -m)"
        case "$arch" in
          x86_64|amd64)  pkg_arch="linux_x64" ;;
          aarch64|arm64) pkg_arch="linux_arm64" ;;
          *) echo "Unsupported arch: $arch"; exit 1 ;;
        esac

        base="https://github.com/gitleaks/gitleaks/releases/download/${ver}"
        tgz="gitleaks_${file_ver}_${pkg_arch}.tar.gz"

        echo "üì• Installing Gitleaks $ver..."
        curl -sSL "$base/$tgz" -o gitleaks.tgz
        tar -xzf gitleaks.tgz gitleaks
        chmod +x gitleaks

        install_dir="$HOME/.local/bin"
        mkdir -p "$install_dir"
        mv gitleaks "$install_dir/gitleaks"
        echo "$install_dir" >> "$GITHUB_PATH"
        "$install_dir/gitleaks" version

    - name: Sanity check PATH (should find gitleaks)
      shell: bash
      run: |
        set -euo pipefail
        command -v gitleaks
        gitleaks version

    - name: Check for optional config
      id: config
      shell: bash
      run: |
        set -euo pipefail
        if [[ -f "gitleaks.toml" ]]; then
          echo "config_arg=-c gitleaks.toml" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Found config: gitleaks.toml"
        else
          echo "config_arg=" >> "$GITHUB_OUTPUT"
          echo "‚ö†Ô∏è Config file not found. Proceeding with default rules."
        fi

    - name: Collect PR patch (files & added lines)
      id: prpatch
      if: ${{ inputs.scan_mode == 'diff' }}
      shell: bash
      run: |
        set -euo pipefail

        # 1) –û–ø—Ä–µ–¥–µ–ª—è–µ–º HEAD/BASE
        HEAD_SHA="$(git rev-parse HEAD)"
        BASE_SHA="${{ inputs.base_sha }}"
        if [[ -z "${BASE_SHA}" && -n "${GITHUB_BASE_REF:-}" ]]; then
          git fetch --no-tags origin "${GITHUB_BASE_REF}:${GITHUB_BASE_REF}"
          BASE_SHA="$(git rev-parse "origin/${GITHUB_BASE_REF}")"
        fi
        if [[ -z "${BASE_SHA}" ]]; then
          echo "No BASE SHA for PR; empty patch."
          echo "src_dir=" >> "$GITHUB_OUTPUT"
          echo "patch_map=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # 2) –¢–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ/–∏–∑–º–µ–Ω—ë–Ω–Ω—ã–µ/–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã (–±–µ–∑ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö)
        mapfile -t FILES < <(git diff --name-only --diff-filter=AMR "${BASE_SHA}" "${HEAD_SHA}")

        # –ü—É—Å—Ç–æ–π –ø–∞—Ç—á? ‚Äî –≤—ã—Ö–æ–¥–∏–º –º—è–≥–∫–æ.
        if (( ${#FILES[@]} == 0 )); then
          echo "No changed files."
          echo "src_dir=" >> "$GITHUB_OUTPUT"
          echo "patch_map=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # 3) –ì–æ—Ç–æ–≤–∏–º tmp-–¥–µ—Ä–µ–≤–æ —Ç–æ–ª—å–∫–æ –∏–∑ –∏–∑–º–µ–Ω—ë–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        SRC_DIR="$(mktemp -d)"
        for f in "${FILES[@]}"; do
          [[ -f "$f" ]] || continue
          mkdir -p "${SRC_DIR}/$(dirname "$f")"
          # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏
          cp "$f" "${SRC_DIR}/$f"
        done

        # 4) –°–æ–±–∏—Ä–∞–µ–º ¬´–∫–∞—Ä—Ç—É –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫¬ª –ø–æ –∫–∞–∂–¥–æ–º—É —Ñ–∞–π–ª—É (–¥–ª—è –ø–æ—Å—Ç-—Ñ–∏–ª—å—Ç—Ä–∞ –Ω–∞—Ö–æ–¥–æ–∫)
        # –§–æ—Ä–º–∞—Ç: JSON { "file": [[start,end], ...], ... }
        PATCH_JSON="$(mktemp)"
        echo '{}' > "$PATCH_JSON"

        # –í zero-context –¥–∏—Ñ—Ñ–µ –∫–∞–∂–¥–∞—è –¥–æ–±–∞–≤–∫–∞ –¥–∞—ë—Ç @@ -a,b +c,d @@
        # –í–æ–∑—å–º—ë–º —Ç–æ–ª—å–∫–æ –ø–ª—é—Å–æ–≤—ã–µ hunks (+c,d)
        while IFS= read -r file; do
          # –∏–∑–≤–ª–µ–∫–∞–µ–º hunks —Ç–æ–ª—å–∫–æ –¥–ª—è —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞, —Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
          HUNKS="$(git diff --unified=0 "${BASE_SHA}" "${HEAD_SHA}" -- "$file" \
            | awk '/^@@/ {print}' \
            | sed -n 's/.*+\([0-9]\+\),\([0-9]\+\).*/\1 \2/p')"

          # —Å–æ–±–∏—Ä–∞–µ–º –º–∞—Å—Å–∏–≤ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
          RANGES=()
          while read -r start count; do
            [[ -z "${start:-}" || -z "${count:-}" ]] && continue
            end=$((start + count - 1))
            RANGES+=("[${start},${end}]")
          done <<< "$HUNKS"

          # –ø–∏—à–µ–º –≤ JSON (–µ—Å–ª–∏ –µ—Å—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è)
          if (( ${#RANGES[@]} > 0 )); then
            jq --arg f "$file" --argjson arr "[$(IFS=,; echo "${RANGES[*]}")]" '. + {($f): $arr}' "$PATCH_JSON" > "$PATCH_JSON.tmp"
            mv "$PATCH_JSON.tmp" "$PATCH_JSON"
          fi
        done <<< "$(printf '%s\n' "${FILES[@]}")"

        echo "Collected ${#FILES[@]} files into: ${SRC_DIR}"
        echo "src_dir=${SRC_DIR}" >> "$GITHUB_OUTPUT"
        echo "patch_map=${PATCH_JSON}" >> "$GITHUB_OUTPUT"

    - name: Gitleaks detect (full)
      if: ${{ inputs.scan_mode == 'full' }}
      shell: bash
      run: |
        set -euo pipefail
        CONFIG_ARG="${{ steps.config.outputs.config_arg }}"
        echo "üïµÔ∏è Running full scan..."
        gitleaks detect --no-banner \
          --report-format json --report-path gitleaks.json \
          $CONFIG_ARG \
          --source .

    - name: Gitleaks detect (patch tree-only)
      if: ${{ inputs.scan_mode == 'diff' }}
      shell: bash
      run: |
        set -euo pipefail
        SRC="${{ steps.prpatch.outputs.src_dir }}"
        CONFIG_ARG="${{ steps.config.outputs.config_arg }}"
        if [[ -z "${SRC}" ]]; then
          echo "No patch to scan."
          touch gitleaks.json
          echo "[]" > gitleaks.json
          exit 0
        fi

        echo "üïµÔ∏è Scanning PR patch (tree-only) in ${SRC}..."
        gitleaks detect --no-banner --no-git \
          --report-format json --report-path gitleaks.json \
          $CONFIG_ARG \
          --source "${SRC}"

    - name: Filter findings by added lines (patch)
      if: ${{ inputs.scan_mode == 'diff' }}
      shell: bash
      run: |
        set -euo pipefail
        PATCH_MAP_PATH="${{ steps.prpatch.outputs.patch_map }}"
        [[ -f "gitleaks.json" ]] || { echo "No gitleaks.json"; exit 0; }

        # –ù–µ—Ç –∫–∞—Ä—Ç—ã ‚Äî –Ω–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–π => –ø—É—Å—Ç–æ–π –æ—Ç—á—ë—Ç
        if [[ -z "${PATCH_MAP_PATH}" || ! -s "${PATCH_MAP_PATH}" ]]; then
          echo "[]" > gitleaks.json
          exit 0
        fi

        # –ß–∏—Ç–∞–µ–º –∫–∞—Ä—Ç—É –∏ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –µ—ë –∫–∞–∫ argjson (–±–µ–∑ --argfile)
        MAP_JSON="$(cat "${PATCH_MAP_PATH}")"

        jq --argjson map "${MAP_JSON}" '
          def norm:
            if type=="object" and has("findings") then .findings
            elif type=="array" then .
            else [] end;

          norm
          | map(
              . as $f
              | ($f.File // $f.file // $f.Target // $f.Location.File // "") as $file
              | ($f.StartLine // $f.Line // $f.Location.StartLine // 0) as $line
              | if ($map[$file] // empty) as $ranges
                | any($ranges[]; $line >= .[0] and $line <= .[1])
                then $f else empty end
            )
        ' gitleaks.json > gitleaks.filtered.json

        mv gitleaks.filtered.json gitleaks.json
        echo "Filtered findings to only added lines in PR patch"

    - name: Print findings (always)
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        [[ -f gitleaks.json ]] || { echo "No gitleaks.json produced"; exit 0; }
        LIMIT=200
        REPO_URL="${{ github.server_url }}/${{ github.repository }}"

        JQ_FILTER='
          def norm:
            {
              file: (.File // .file // .Target // .Location.File // ""),
              line: (.StartLine // .Line // .Location.StartLine // 0),
              rule: (.RuleID // .Rule // .Description // ""),
              commit: (.Commit // .commit // "")
            };
          (if type=="object" and has("findings") then .findings
           elif type=="array" then .
           else [] end)[] | norm
        '

        COUNT=$(jq -r 'if type=="object" and has("findings") then (.findings|length)
                       elif type=="array" then length else 0 end' gitleaks.json)

        echo "Findings: $COUNT"
        echo "### Secret findings :closed_lock_with_key:" >> "$GITHUB_STEP_SUMMARY"
        echo "" >> "$GITHUB_STEP_SUMMARY"
        echo "| Rule | File:Line | Commit | Link |" >> "$GITHUB_STEP_SUMMARY"
        echo "|---|---|---|---|" >> "$GITHUB_STEP_SUMMARY"

        jq -r "$JQ_FILTER | [.rule, (.file+\":\"+(.line|tostring)), (.commit[0:7]),
               (if (.commit|length)>0 and (.file|length)>0 and (.line|tonumber)>0
                then \"$REPO_URL/blob/\"+.commit+\"/\"+.file+\"#L\"+(.line|tostring)
                else \"\" end)]
              | @tsv" gitleaks.json \
          | head -n "$LIMIT" \
          | while IFS=$'\t' read -r rule loc sha link; do
              printf '‚Ä¢ %s %s %s %s\n' "[$rule]" "$loc" "$sha" "$link"
              printf '| `%s` | `%s` | `%s` | %s |\n' "$rule" "$loc" "$sha" "${link:-"-"}" >> "$GITHUB_STEP_SUMMARY"
            done

        if (( COUNT > LIMIT )); then
          MORE=$((COUNT - LIMIT))
          echo "... and $MORE more (see artifact gitleaks-report)." | tee -a "$GITHUB_STEP_SUMMARY"
        fi

    - name: Upload report (always)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: gitleaks-report
        path: gitleaks.json
        if-no-files-found: ignore